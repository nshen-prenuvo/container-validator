#!/usr/bin/env python3
"""
FOMO25 Challenge - Postprocessing Script
Reverses preprocessing transformations to restore original image dimensions and properties
"""
import argparse
import logging
import nibabel as nib
import numpy as np
from pathlib import Path
import sys
import json
from torch import from_numpy
# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def load_nifti(file_path):
    """Load a NIfTI file and return the image data and affine matrix."""
    try:
        img = nib.load(file_path)
        return img.get_fdata(), img.affine, img.header
    except Exception as e:
        logger.error(f"Failed to load NIfTI file {file_path}: {e}")
        raise

def save_nifti(data, affine, header, output_path):
    """Save data as a NIfTI file."""
    try:
        img = nib.Nifti1Image(data, affine, header)
        nib.save(img, output_path)
        logger.info(f"Saved postprocessed image to: {output_path}")
    except Exception as e:
        logger.error(f"Failed to save NIfTI file to {output_path}: {e}")
        raise

def load_case_properties(properties_path):
    """Load case properties from pickle file generated by preprocess.py."""
    try:
        import pickle
        with open(properties_path, 'rb') as f:
            properties = pickle.load(f)
        
        logger.info(f"Loaded case properties from pickle file: {properties_path}")
        
        return properties
        
    except FileNotFoundError:
        logger.error(f"Case properties file not found: {properties_path}")
        raise
    except Exception as e:
        logger.error(f"Failed to load case properties from {properties_path}: {e}")
        raise

def reverse_preprocessing_wrapper(predictions, case_properties, model_config_path, num_classes=2):
    """
    Wrapper for yucca's reverse_preprocessing function.
    
    Args:
        predictions: Segmentation predictions (numpy array) - already binary
        case_properties: Dictionary containing preprocessing properties
        num_classes: Number of segmentation classes
        
    Returns:
        predictions_original: Predictions in original image space
    """
    try:
        # Import yucca's reverse_preprocessing function
        from yucca.functional.preprocessing import reverse_preprocessing
        
        # Load crop_to_nonzero from model_config.json
        config_path = Path(model_config_path)
        with open(config_path, 'r') as f:
            config = json.load(f)
        crop_to_nonzero = config["preprocessing_config"]["crop_to_nonzero"]
        # logger.info(f"Loaded crop_to_nonzero={crop_to_nonzero} from {config_path}")

        # Get transpose parameters from case properties
        transpose_forward = case_properties.get('transpose_forward', [0, 1, 2])
        transpose_backward = case_properties.get('transpose_backward', [0, 1, 2])
        
        # Apply reverse preprocessing
        predictions_tensor = from_numpy(predictions).unsqueeze(0).unsqueeze(0)
        
        predictions_original, _ = reverse_preprocessing(
            crop_to_nonzero=crop_to_nonzero,
            images=predictions_tensor,
            image_properties=case_properties,
            n_classes=num_classes,
            transpose_forward=transpose_forward,
            transpose_backward=transpose_backward,
        )
        
        # convert predictions_original to binary and squeeze the extra dimensions
        predictions_original = predictions_original.astype(np.uint8).squeeze(0).squeeze(0)
        return predictions_original
        
    except ImportError as e:
        logger.error(f"Failed to import yucca.reverse_preprocessing: {e}")
        logger.error("Make sure yucca is installed and accessible")
        raise
    except Exception as e:
        logger.error(f"Error in reverse_preprocessing: {e}")
        raise

def main():
    """Main postprocessing function."""
    parser = argparse.ArgumentParser(description="FOMO25 Postprocessing Script")
    
    parser.add_argument("--input", type=str, required=True,
                       help="Path to segmentation predictions from predict.py")
    parser.add_argument("--properties_file", type=str, required=True,
                       help="Path to preprocessing properties pickle file from preprocess.py")
    parser.add_argument("--output", type=str, required=True,
                       help="Path to save postprocessed segmentation")
    parser.add_argument("--num_classes", type=int, default=1,
                       help="Number of segmentation classes (default: 1)")
    parser.add_argument("--model_config", type=str, default="/app/model_config.json",
                       help="Path to model configuration file (default: model_config.json)")
    parser.add_argument("--original_affine", type=str, default=None,
                       help="Path to saved affine matrix file (default: looks for affine.npy in properties directory)")
    
    args = parser.parse_args()
    
    # Validate input files exist
    if not Path(args.input).exists():
        logger.error(f"Input file not found: {args.input}")
        sys.exit(1)
    
    if not Path(args.properties_file).exists():
        logger.error(f"Case properties file not found: {args.properties_file}")
        sys.exit(1)
    
    # Create output directory if it doesn't exist
    Path(args.output).parent.mkdir(parents=True, exist_ok=True)
    
    try:
        # Load segmentation predictions
        logger.info(f"Loading segmentation predictions from: {args.input}")
        predictions, affine, header = load_nifti(args.input)
        
        # Load case properties
        logger.info(f"Loading case properties from: {args.properties_file}")
        case_properties = load_case_properties(args.properties_file)
        
        # Load original affine matrix
        original_affine = np.load(args.original_affine)
        logger.info(f"Loaded affine matrix from specified file: {args.original_affine}")
        
        # Apply reverse preprocessing (input is already binary)
        logger.info("Applying reverse preprocessing...")
        predictions_original = reverse_preprocessing_wrapper(
            predictions, case_properties, args.model_config, args.num_classes
        )
        
        # Save postprocessed results with original affine matrix
        logger.info(f"Saving postprocessed segmentation to: {args.output}")
        save_nifti(predictions_original, original_affine, header, args.output)
        
        logger.info("Postprocessing completed successfully!")
        
    except Exception as e:
        logger.error(f"Postprocessing failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
